{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n// Multi-device Conversation is a Preview feature.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n/* eslint-disable max-classes-per-file */\nimport { ConversationConnectionConfig, ServicePropertiesPropertyName } from \"../../common.speech/Exports\";\nimport { ConversationTranslatorConnectionFactory } from \"../../common.speech/Transcription/ConversationTranslatorConnectionFactory\";\nimport { marshalPromiseToCallbacks } from \"../../common/Exports\";\nimport { Contracts } from \"../Contracts\";\nimport { AudioConfig, CancellationErrorCode, CancellationReason, ProfanityOption, PropertyCollection, PropertyId, ServicePropertyChannel, SpeechTranslationConfig, TranslationRecognizer } from \"../Exports\";\nimport { ConversationImpl } from \"./Conversation\";\nimport { ConversationCommon, ConversationTranslationCanceledEventArgs } from \"./Exports\";\nexport var SpeechState;\n(function (SpeechState) {\n  SpeechState[SpeechState[\"Inactive\"] = 0] = \"Inactive\";\n  SpeechState[SpeechState[\"Connecting\"] = 1] = \"Connecting\";\n  SpeechState[SpeechState[\"Connected\"] = 2] = \"Connected\";\n})(SpeechState || (SpeechState = {}));\n// child class of TranslationRecognizer meant only for use with ConversationTranslator\nclass ConversationTranslationRecognizer extends TranslationRecognizer {\n  constructor(speechConfig, audioConfig, translator, convGetter) {\n    super(speechConfig, audioConfig, new ConversationTranslatorConnectionFactory(convGetter));\n    this.privSpeechState = SpeechState.Inactive;\n    if (!!translator) {\n      this.privTranslator = translator;\n      this.sessionStarted = () => {\n        this.privSpeechState = SpeechState.Connected;\n      };\n      this.sessionStopped = () => {\n        this.privSpeechState = SpeechState.Inactive;\n      };\n      this.recognizing = (tr, e) => {\n        if (!!this.privTranslator.recognizing) {\n          this.privTranslator.recognizing(this.privTranslator, e);\n        }\n      };\n      // eslint-disable-next-line @typescript-eslint/no-misused-promises\n      this.recognized = (tr, e) => __awaiter(this, void 0, void 0, function* () {\n        var _a;\n        // if there is an error connecting to the conversation service from the speech service the error will be returned in the ErrorDetails field.\n        if ((_a = e.result) === null || _a === void 0 ? void 0 : _a.errorDetails) {\n          yield this.cancelSpeech();\n          // TODO: format the error message contained in 'errorDetails'\n          this.fireCancelEvent(e.result.errorDetails);\n        } else {\n          if (!!this.privTranslator.recognized) {\n            this.privTranslator.recognized(this.privTranslator, e);\n          }\n        }\n        return;\n      });\n      // eslint-disable-next-line @typescript-eslint/no-misused-promises\n      this.canceled = () => __awaiter(this, void 0, void 0, function* () {\n        if (this.privSpeechState !== SpeechState.Inactive) {\n          try {\n            yield this.cancelSpeech();\n          } catch (error) {\n            this.privSpeechState = SpeechState.Inactive;\n          }\n        }\n      });\n    }\n  }\n  get state() {\n    return this.privSpeechState;\n  }\n  set state(newState) {\n    this.privSpeechState = newState;\n  }\n  onConnection() {\n    this.privSpeechState = SpeechState.Connected;\n  }\n  onDisconnection() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.privSpeechState = SpeechState.Inactive;\n      yield this.cancelSpeech();\n    });\n  }\n  /**\n   * Fire a cancel event\n   * @param error\n   */\n  fireCancelEvent(error) {\n    try {\n      if (!!this.privTranslator.canceled) {\n        const cancelEvent = new ConversationTranslationCanceledEventArgs(CancellationReason.Error, error, CancellationErrorCode.RuntimeError);\n        this.privTranslator.canceled(this.privTranslator, cancelEvent);\n      }\n    } catch (e) {\n      //\n    }\n  }\n  cancelSpeech() {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        this.stopContinuousRecognitionAsync();\n        yield (_a = this.privReco) === null || _a === void 0 ? void 0 : _a.disconnect();\n        this.privSpeechState = SpeechState.Inactive;\n      } catch (e) {\n        // ignore the error\n      }\n    });\n  }\n}\n/**\n * Join, leave or connect to a conversation.\n */\nexport class ConversationTranslator extends ConversationCommon {\n  constructor(audioConfig) {\n    super(audioConfig);\n    this.privErrors = ConversationConnectionConfig.restErrors;\n    this.privIsDisposed = false;\n    this.privIsSpeaking = false;\n    this.privPlaceholderKey = \"abcdefghijklmnopqrstuvwxyz012345\";\n    this.privPlaceholderRegion = \"westus\";\n    this.privProperties = new PropertyCollection();\n  }\n  get properties() {\n    return this.privProperties;\n  }\n  get speechRecognitionLanguage() {\n    return this.privSpeechRecognitionLanguage;\n  }\n  get participants() {\n    var _a;\n    return (_a = this.privConversation) === null || _a === void 0 ? void 0 : _a.participants;\n  }\n  get canSpeak() {\n    // is there a Conversation websocket available and has the Recognizer been set up\n    if (!this.privConversation.isConnected || !this.privCTRecognizer) {\n      return false;\n    }\n    // is the user already speaking\n    if (this.privIsSpeaking || this.privCTRecognizer.state === SpeechState.Connected || this.privCTRecognizer.state === SpeechState.Connecting) {\n      return false;\n    }\n    // is the user muted\n    if (this.privConversation.isMutedByHost) {\n      return false;\n    }\n    return true;\n  }\n  setServiceProperty(name, value) {\n    const currentProperties = JSON.parse(this.privProperties.getProperty(ServicePropertiesPropertyName, \"{}\"));\n    currentProperties[name] = value;\n    this.privProperties.setProperty(ServicePropertiesPropertyName, JSON.stringify(currentProperties));\n  }\n  joinConversationAsync(conversation, nickname, param1, param2, param3) {\n    try {\n      if (typeof conversation === \"string\") {\n        Contracts.throwIfNullOrUndefined(conversation, this.privErrors.invalidArgs.replace(\"{arg}\", \"conversation id\"));\n        Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace(\"{arg}\", \"nickname\"));\n        if (!!this.privConversation) {\n          this.handleError(new Error(this.privErrors.permissionDeniedStart), param3);\n        }\n        let lang = param1;\n        if (lang === undefined || lang === null || lang === \"\") {\n          lang = ConversationConnectionConfig.defaultLanguageCode;\n        }\n        // create a placeholder config\n        this.privSpeechTranslationConfig = SpeechTranslationConfig.fromSubscription(this.privPlaceholderKey, this.privPlaceholderRegion);\n        this.privSpeechTranslationConfig.setProfanity(ProfanityOption.Masked);\n        this.privSpeechTranslationConfig.addTargetLanguage(lang);\n        this.privSpeechTranslationConfig.setProperty(PropertyId[PropertyId.SpeechServiceConnection_RecoLanguage], lang);\n        this.privSpeechTranslationConfig.setProperty(PropertyId[PropertyId.ConversationTranslator_Name], nickname);\n        const propertyIdsToCopy = [PropertyId.SpeechServiceConnection_Host, PropertyId.ConversationTranslator_Host, PropertyId.SpeechServiceConnection_Endpoint, PropertyId.SpeechServiceConnection_ProxyHostName, PropertyId.SpeechServiceConnection_ProxyPassword, PropertyId.SpeechServiceConnection_ProxyPort, PropertyId.SpeechServiceConnection_ProxyUserName, \"ConversationTranslator_MultiChannelAudio\", \"ConversationTranslator_Region\"];\n        for (const prop of propertyIdsToCopy) {\n          const value = this.privProperties.getProperty(prop);\n          if (value) {\n            const key = typeof prop === \"string\" ? prop : PropertyId[prop];\n            this.privSpeechTranslationConfig.setProperty(key, value);\n          }\n        }\n        const currentProperties = JSON.parse(this.privProperties.getProperty(ServicePropertiesPropertyName, \"{}\"));\n        for (const prop of Object.keys(currentProperties)) {\n          this.privSpeechTranslationConfig.setServiceProperty(prop, currentProperties[prop], ServicePropertyChannel.UriQueryParameter);\n        }\n        // join the conversation\n        this.privConversation = new ConversationImpl(this.privSpeechTranslationConfig);\n        this.privConversation.conversationTranslator = this;\n        this.privConversation.joinConversationAsync(conversation, nickname, lang, result => {\n          if (!result) {\n            this.handleError(new Error(this.privErrors.permissionDeniedConnect), param3);\n          }\n          this.privSpeechTranslationConfig.authorizationToken = result;\n          this.privConversation.room.isHost = false;\n          // connect to the ws\n          this.privConversation.startConversationAsync(() => {\n            this.handleCallback(param2, param3);\n          }, error => {\n            this.handleError(error, param3);\n          });\n        }, error => {\n          this.handleError(error, param3);\n        });\n      } else if (typeof conversation === \"object\") {\n        Contracts.throwIfNullOrUndefined(conversation, this.privErrors.invalidArgs.replace(\"{arg}\", \"conversation id\"));\n        Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace(\"{arg}\", \"nickname\"));\n        // save the nickname\n        this.privProperties.setProperty(PropertyId.ConversationTranslator_Name, nickname);\n        // ref the conversation object\n        this.privConversation = conversation;\n        // ref the conversation translator object\n        this.privConversation.conversationTranslator = this;\n        this.privConversation.room.isHost = true;\n        Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedConnect);\n        Contracts.throwIfNullOrUndefined(this.privConversation.room.token, this.privErrors.permissionDeniedConnect);\n        this.privSpeechTranslationConfig = conversation.config;\n        this.handleCallback(param1, param2);\n      } else {\n        this.handleError(new Error(this.privErrors.invalidArgs.replace(\"{arg}\", \"invalid conversation type\")), param2);\n      }\n    } catch (error) {\n      this.handleError(error, typeof param1 === \"string\" ? param3 : param2);\n    }\n  }\n  /**\n   * Leave the conversation\n   * @param cb\n   * @param err\n   */\n  leaveConversationAsync(cb, err) {\n    marshalPromiseToCallbacks((() => __awaiter(this, void 0, void 0, function* () {\n      // stop the speech websocket\n      yield this.cancelSpeech();\n      // stop the websocket\n      yield this.privConversation.endConversationImplAsync();\n      // https delete request\n      yield this.privConversation.deleteConversationImplAsync();\n      this.dispose();\n    }))(), cb, err);\n  }\n  /**\n   * Send a text message\n   * @param message\n   * @param cb\n   * @param err\n   */\n  sendTextMessageAsync(message, cb, err) {\n    try {\n      Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedSend);\n      Contracts.throwIfNullOrWhitespace(message, this.privErrors.invalidArgs.replace(\"{arg}\", message));\n      this.privConversation.sendTextMessageAsync(message, cb, err);\n    } catch (error) {\n      this.handleError(error, err);\n    }\n  }\n  /**\n   * Start speaking\n   * @param cb\n   * @param err\n   */\n  startTranscribingAsync(cb, err) {\n    marshalPromiseToCallbacks((() => __awaiter(this, void 0, void 0, function* () {\n      try {\n        Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedSend);\n        Contracts.throwIfNullOrUndefined(this.privConversation.room.token, this.privErrors.permissionDeniedConnect);\n        if (this.privCTRecognizer === undefined) {\n          yield this.connectTranslatorRecognizer();\n        }\n        Contracts.throwIfNullOrUndefined(this.privCTRecognizer, this.privErrors.permissionDeniedSend);\n        if (!this.canSpeak) {\n          this.handleError(new Error(this.privErrors.permissionDeniedSend), err);\n        }\n        yield this.startContinuousRecognition();\n        this.privIsSpeaking = true;\n      } catch (error) {\n        this.privIsSpeaking = false;\n        yield this.cancelSpeech();\n        throw error;\n      }\n    }))(), cb, err);\n  }\n  /**\n   * Stop speaking\n   * @param cb\n   * @param err\n   */\n  stopTranscribingAsync(cb, err) {\n    marshalPromiseToCallbacks((() => __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!this.privIsSpeaking) {\n          // stop speech\n          yield this.cancelSpeech();\n          return;\n        }\n        // stop the recognition but leave the websocket open\n        this.privIsSpeaking = false;\n        yield new Promise((resolve, reject) => {\n          this.privCTRecognizer.stopContinuousRecognitionAsync(resolve, reject);\n        });\n      } catch (error) {\n        yield this.cancelSpeech();\n      }\n    }))(), cb, err);\n  }\n  isDisposed() {\n    return this.privIsDisposed;\n  }\n  dispose(reason, success, err) {\n    marshalPromiseToCallbacks((() => __awaiter(this, void 0, void 0, function* () {\n      if (this.isDisposed && !this.privIsSpeaking) {\n        return;\n      }\n      yield this.cancelSpeech();\n      this.privIsDisposed = true;\n      this.privSpeechTranslationConfig.close();\n      this.privSpeechRecognitionLanguage = undefined;\n      this.privProperties = undefined;\n      this.privAudioConfig = undefined;\n      this.privSpeechTranslationConfig = undefined;\n      this.privConversation.dispose();\n      this.privConversation = undefined;\n    }))(), success, err);\n  }\n  /**\n   * Cancel the speech websocket\n   */\n  cancelSpeech() {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        this.privIsSpeaking = false;\n        yield (_a = this.privCTRecognizer) === null || _a === void 0 ? void 0 : _a.onDisconnection();\n        this.privCTRecognizer = undefined;\n      } catch (e) {\n        // ignore the error\n      }\n    });\n  }\n  /**\n   * Connect to the speech translation recognizer.\n   * Currently there is no language validation performed before sending the SpeechLanguage code to the service.\n   * If it's an invalid language the raw error will be: 'Error during WebSocket handshake: Unexpected response code: 400'\n   * e.g. pass in 'fr' instead of 'fr-FR', or a text-only language 'cy'\n   */\n  connectTranslatorRecognizer() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (this.privAudioConfig === undefined) {\n          this.privAudioConfig = AudioConfig.fromDefaultMicrophoneInput();\n        }\n        // clear the temp subscription key if it's a participant joining\n        if (this.privSpeechTranslationConfig.getProperty(PropertyId[PropertyId.SpeechServiceConnection_Key]) === this.privPlaceholderKey) {\n          this.privSpeechTranslationConfig.setProperty(PropertyId[PropertyId.SpeechServiceConnection_Key], \"\");\n        }\n        const convGetter = () => this.privConversation;\n        this.privCTRecognizer = new ConversationTranslationRecognizer(this.privSpeechTranslationConfig, this.privAudioConfig, this, convGetter);\n      } catch (error) {\n        yield this.cancelSpeech();\n        throw error;\n      }\n    });\n  }\n  /**\n   * Handle the start speaking request\n   */\n  startContinuousRecognition() {\n    return new Promise((resolve, reject) => {\n      this.privCTRecognizer.startContinuousRecognitionAsync(resolve, reject);\n    });\n  }\n}","map":{"version":3,"names":["ConversationConnectionConfig","ServicePropertiesPropertyName","ConversationTranslatorConnectionFactory","marshalPromiseToCallbacks","Contracts","AudioConfig","CancellationErrorCode","CancellationReason","ProfanityOption","PropertyCollection","PropertyId","ServicePropertyChannel","SpeechTranslationConfig","TranslationRecognizer","ConversationImpl","ConversationCommon","ConversationTranslationCanceledEventArgs","SpeechState","ConversationTranslationRecognizer","constructor","speechConfig","audioConfig","translator","convGetter","privSpeechState","Inactive","privTranslator","sessionStarted","Connected","sessionStopped","recognizing","tr","e","recognized","__awaiter","_a","result","errorDetails","cancelSpeech","fireCancelEvent","canceled","error","state","newState","onConnection","onDisconnection","cancelEvent","Error","RuntimeError","stopContinuousRecognitionAsync","privReco","disconnect","ConversationTranslator","privErrors","restErrors","privIsDisposed","privIsSpeaking","privPlaceholderKey","privPlaceholderRegion","privProperties","properties","speechRecognitionLanguage","privSpeechRecognitionLanguage","participants","privConversation","canSpeak","isConnected","privCTRecognizer","Connecting","isMutedByHost","setServiceProperty","name","value","currentProperties","JSON","parse","getProperty","setProperty","stringify","joinConversationAsync","conversation","nickname","param1","param2","param3","throwIfNullOrUndefined","invalidArgs","replace","throwIfNullOrWhitespace","handleError","permissionDeniedStart","lang","undefined","defaultLanguageCode","privSpeechTranslationConfig","fromSubscription","setProfanity","Masked","addTargetLanguage","SpeechServiceConnection_RecoLanguage","ConversationTranslator_Name","propertyIdsToCopy","SpeechServiceConnection_Host","ConversationTranslator_Host","SpeechServiceConnection_Endpoint","SpeechServiceConnection_ProxyHostName","SpeechServiceConnection_ProxyPassword","SpeechServiceConnection_ProxyPort","SpeechServiceConnection_ProxyUserName","prop","key","Object","keys","UriQueryParameter","conversationTranslator","permissionDeniedConnect","authorizationToken","room","isHost","startConversationAsync","handleCallback","token","config","leaveConversationAsync","cb","err","endConversationImplAsync","deleteConversationImplAsync","dispose","sendTextMessageAsync","message","permissionDeniedSend","startTranscribingAsync","connectTranslatorRecognizer","startContinuousRecognition","stopTranscribingAsync","Promise","resolve","reject","isDisposed","reason","success","close","privAudioConfig","fromDefaultMicrophoneInput","SpeechServiceConnection_Key","startContinuousRecognitionAsync"],"sources":["src/sdk/Transcription/ConversationTranslator.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n// Multi-device Conversation is a Preview feature.\r\n\r\n/* eslint-disable max-classes-per-file */\r\n\r\nimport {\r\n    ConversationConnectionConfig,\r\n    ServicePropertiesPropertyName,\r\n} from \"../../common.speech/Exports\";\r\nimport { ConversationTranslatorConnectionFactory } from \"../../common.speech/Transcription/ConversationTranslatorConnectionFactory\";\r\nimport {\r\n    IDisposable,\r\n    IErrorMessages,\r\n    IStringDictionary,\r\n    marshalPromiseToCallbacks\r\n} from \"../../common/Exports\";\r\nimport { Contracts } from \"../Contracts\";\r\nimport {\r\n    AudioConfig,\r\n    CancellationErrorCode,\r\n    CancellationReason,\r\n    ProfanityOption,\r\n    PropertyCollection,\r\n    PropertyId,\r\n    ServicePropertyChannel,\r\n    SessionEventArgs,\r\n    SpeechTranslationConfig,\r\n    TranslationRecognitionEventArgs,\r\n    TranslationRecognizer\r\n} from \"../Exports\";\r\nimport { ConversationImpl } from \"./Conversation\";\r\nimport {\r\n    ConversationCommon,\r\n    ConversationExpirationEventArgs,\r\n    ConversationHandler,\r\n    ConversationParticipantsChangedEventArgs,\r\n    ConversationTranslationCanceledEventArgs,\r\n    ConversationTranslationEventArgs,\r\n    IConversationTranslator,\r\n    Participant\r\n} from \"./Exports\";\r\nimport { Callback, IConversation } from \"./IConversation\";\r\n\r\nexport enum SpeechState {\r\n    Inactive, Connecting, Connected\r\n}\r\n\r\n// child class of TranslationRecognizer meant only for use with ConversationTranslator\r\nclass ConversationTranslationRecognizer extends TranslationRecognizer {\r\n    private privTranslator: ConversationTranslator;\r\n    private privSpeechState: SpeechState;\r\n\r\n    public constructor(speechConfig: SpeechTranslationConfig, audioConfig: AudioConfig, translator: ConversationTranslator, convGetter: () => ConversationImpl) {\r\n\r\n        super(speechConfig, audioConfig, new ConversationTranslatorConnectionFactory(convGetter));\r\n\r\n        this.privSpeechState = SpeechState.Inactive;\r\n        if (!!translator) {\r\n            this.privTranslator = translator;\r\n            this.sessionStarted = (): void => {\r\n                this.privSpeechState = SpeechState.Connected;\r\n            };\r\n\r\n            this.sessionStopped = (): void => {\r\n                this.privSpeechState = SpeechState.Inactive;\r\n            };\r\n\r\n            this.recognizing = (tr: TranslationRecognizer, e: TranslationRecognitionEventArgs): void => {\r\n                if (!!this.privTranslator.recognizing) {\r\n                    this.privTranslator.recognizing(this.privTranslator, e);\r\n                }\r\n            };\r\n\r\n            // eslint-disable-next-line @typescript-eslint/no-misused-promises\r\n            this.recognized = async (tr: TranslationRecognizer, e: TranslationRecognitionEventArgs): Promise<void> => {\r\n                // if there is an error connecting to the conversation service from the speech service the error will be returned in the ErrorDetails field.\r\n                if (e.result?.errorDetails) {\r\n                    await this.cancelSpeech();\r\n                    // TODO: format the error message contained in 'errorDetails'\r\n                    this.fireCancelEvent(e.result.errorDetails);\r\n                } else {\r\n                    if (!!this.privTranslator.recognized) {\r\n                        this.privTranslator.recognized(this.privTranslator, e);\r\n                    }\r\n                }\r\n                return;\r\n            };\r\n\r\n            // eslint-disable-next-line @typescript-eslint/no-misused-promises\r\n            this.canceled = async (): Promise<void> => {\r\n                if (this.privSpeechState !== SpeechState.Inactive) {\r\n                    try {\r\n                        await this.cancelSpeech();\r\n                    } catch (error) {\r\n                        this.privSpeechState = SpeechState.Inactive;\r\n                    }\r\n                }\r\n            };\r\n        }\r\n    }\r\n\r\n    public get state(): SpeechState {\r\n        return this.privSpeechState;\r\n    }\r\n\r\n    public set state(newState: SpeechState) {\r\n        this.privSpeechState = newState;\r\n    }\r\n\r\n    public onConnection(): void {\r\n        this.privSpeechState = SpeechState.Connected;\r\n    }\r\n\r\n    public async onDisconnection(): Promise<void> {\r\n        this.privSpeechState = SpeechState.Inactive;\r\n        await this.cancelSpeech();\r\n    }\r\n\r\n    /**\r\n     * Fire a cancel event\r\n     * @param error\r\n     */\r\n    private fireCancelEvent(error: string): void {\r\n        try {\r\n            if (!!this.privTranslator.canceled) {\r\n                const cancelEvent: ConversationTranslationCanceledEventArgs = new ConversationTranslationCanceledEventArgs(\r\n                    CancellationReason.Error,\r\n                    error,\r\n                    CancellationErrorCode.RuntimeError\r\n                    );\r\n\r\n                this.privTranslator.canceled(this.privTranslator, cancelEvent);\r\n            }\r\n        } catch (e) {\r\n            //\r\n        }\r\n    }\r\n\r\n    private async cancelSpeech(): Promise<void> {\r\n        try {\r\n            this.stopContinuousRecognitionAsync();\r\n            await this.privReco?.disconnect();\r\n            this.privSpeechState = SpeechState.Inactive;\r\n        } catch (e) {\r\n            // ignore the error\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Join, leave or connect to a conversation.\r\n */\r\nexport class ConversationTranslator extends ConversationCommon implements IConversationTranslator, IDisposable {\r\n\r\n    public canceled: (sender: ConversationHandler, event: ConversationTranslationCanceledEventArgs) => void;\r\n    public conversationExpiration: (sender: IConversationTranslator, event: ConversationExpirationEventArgs) => void;\r\n    public participantsChanged: (sender: IConversationTranslator, event: ConversationParticipantsChangedEventArgs) => void;\r\n    public sessionStarted: (sender: ConversationHandler, event: SessionEventArgs) => void;\r\n    public sessionStopped: (sender: ConversationHandler, event: SessionEventArgs) => void;\r\n    public textMessageReceived: (sender: IConversationTranslator, event: ConversationTranslationEventArgs) => void;\r\n\r\n    // Callbacks for whole conversation results\r\n    public transcribed: (sender: IConversationTranslator, event: ConversationTranslationEventArgs) => void;\r\n    public transcribing: (sender: IConversationTranslator, event: ConversationTranslationEventArgs) => void;\r\n\r\n    // Callbacks for detecting speech/translation results from self\r\n    public recognized: (sender: IConversationTranslator, event: TranslationRecognitionEventArgs) => void;\r\n    public recognizing: (sender: IConversationTranslator, event: TranslationRecognitionEventArgs) => void;\r\n\r\n    private privSpeechRecognitionLanguage: string;\r\n    private privProperties: PropertyCollection;\r\n    private privIsDisposed: boolean;\r\n    private privCTRecognizer: ConversationTranslationRecognizer;\r\n    private privIsSpeaking: boolean;\r\n    private privConversation: ConversationImpl;\r\n    private privErrors: IErrorMessages = ConversationConnectionConfig.restErrors;\r\n    private privPlaceholderKey: string;\r\n    private privPlaceholderRegion: string;\r\n\r\n    public constructor(audioConfig?: AudioConfig) {\r\n        super(audioConfig);\r\n        this.privIsDisposed = false;\r\n        this.privIsSpeaking = false;\r\n        this.privPlaceholderKey = \"abcdefghijklmnopqrstuvwxyz012345\";\r\n        this.privPlaceholderRegion = \"westus\";\r\n        this.privProperties = new PropertyCollection();\r\n    }\r\n\r\n    public get properties(): PropertyCollection {\r\n        return this.privProperties;\r\n    }\r\n\r\n    public get speechRecognitionLanguage(): string {\r\n        return this.privSpeechRecognitionLanguage;\r\n    }\r\n\r\n    public get participants(): Participant[] {\r\n        return this.privConversation?.participants;\r\n    }\r\n\r\n    private get canSpeak(): boolean {\r\n\r\n        // is there a Conversation websocket available and has the Recognizer been set up\r\n        if (!this.privConversation.isConnected || !this.privCTRecognizer) {\r\n            return false;\r\n        }\r\n\r\n        // is the user already speaking\r\n        if (this.privIsSpeaking || this.privCTRecognizer.state === SpeechState.Connected || this.privCTRecognizer.state === SpeechState.Connecting) {\r\n            return false;\r\n        }\r\n\r\n        // is the user muted\r\n        if (this.privConversation.isMutedByHost) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public setServiceProperty(name: string, value: string): void {\r\n        const currentProperties: IStringDictionary<string> = JSON.parse(this.privProperties.getProperty(ServicePropertiesPropertyName, \"{}\")) as IStringDictionary<string>;\r\n\r\n        currentProperties[name] = value;\r\n\r\n        this.privProperties.setProperty(ServicePropertiesPropertyName, JSON.stringify(currentProperties));\r\n    }\r\n\r\n    /**\r\n     * Join a conversation. If this is the host, pass in the previously created Conversation object.\r\n     * @param conversation\r\n     * @param nickname\r\n     * @param lang\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public joinConversationAsync(conversation: IConversation, nickname: string, cb?: Callback, err?: Callback): void;\r\n    public joinConversationAsync(conversationId: string, nickname: string, lang: string, cb?: Callback, err?: Callback): void;\r\n    public joinConversationAsync(conversation: string | IConversation, nickname: string, param1?: string | Callback, param2?: Callback, param3?: Callback): void {\r\n\r\n        try {\r\n\r\n            if (typeof conversation === \"string\") {\r\n\r\n                Contracts.throwIfNullOrUndefined(conversation, this.privErrors.invalidArgs.replace(\"{arg}\", \"conversation id\"));\r\n                Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace(\"{arg}\", \"nickname\"));\r\n\r\n                if (!!this.privConversation) {\r\n                    this.handleError(new Error(this.privErrors.permissionDeniedStart), param3);\r\n                }\r\n\r\n                let lang: string = param1 as string;\r\n                if (lang === undefined || lang === null || lang === \"\") {\r\n                    lang = ConversationConnectionConfig.defaultLanguageCode;\r\n                }\r\n\r\n                // create a placeholder config\r\n                this.privSpeechTranslationConfig = SpeechTranslationConfig.fromSubscription(\r\n                    this.privPlaceholderKey,\r\n                    this.privPlaceholderRegion);\r\n                this.privSpeechTranslationConfig.setProfanity(ProfanityOption.Masked);\r\n                this.privSpeechTranslationConfig.addTargetLanguage(lang);\r\n                this.privSpeechTranslationConfig.setProperty(PropertyId[PropertyId.SpeechServiceConnection_RecoLanguage], lang);\r\n                this.privSpeechTranslationConfig.setProperty(PropertyId[PropertyId.ConversationTranslator_Name], nickname);\r\n\r\n                const propertyIdsToCopy: (string | PropertyId)[] = [\r\n                    PropertyId.SpeechServiceConnection_Host,\r\n                    PropertyId.ConversationTranslator_Host,\r\n                    PropertyId.SpeechServiceConnection_Endpoint,\r\n                    PropertyId.SpeechServiceConnection_ProxyHostName,\r\n                    PropertyId.SpeechServiceConnection_ProxyPassword,\r\n                    PropertyId.SpeechServiceConnection_ProxyPort,\r\n                    PropertyId.SpeechServiceConnection_ProxyUserName,\r\n                    \"ConversationTranslator_MultiChannelAudio\",\r\n                    \"ConversationTranslator_Region\"\r\n                ];\r\n\r\n                for (const prop of propertyIdsToCopy) {\r\n                    const value = this.privProperties.getProperty(prop);\r\n                    if (value) {\r\n                        const key = typeof prop === \"string\" ? prop : PropertyId[prop];\r\n                        this.privSpeechTranslationConfig.setProperty(key, value);\r\n                    }\r\n                }\r\n\r\n                const currentProperties  = JSON.parse(this.privProperties.getProperty(ServicePropertiesPropertyName, \"{}\")) as IStringDictionary<string>;\r\n                for (const prop of Object.keys(currentProperties)) {\r\n                    this.privSpeechTranslationConfig.setServiceProperty(prop, currentProperties[prop], ServicePropertyChannel.UriQueryParameter);\r\n                }\r\n\r\n                // join the conversation\r\n                this.privConversation = new ConversationImpl(this.privSpeechTranslationConfig);\r\n                this.privConversation.conversationTranslator = this;\r\n\r\n                this.privConversation.joinConversationAsync(\r\n                    conversation,\r\n                    nickname,\r\n                    lang,\r\n                    ((result: string): void => {\r\n\r\n                        if (!result) {\r\n                            this.handleError(new Error(this.privErrors.permissionDeniedConnect), param3);\r\n                        }\r\n\r\n                        this.privSpeechTranslationConfig.authorizationToken = result;\r\n                        this.privConversation.room.isHost = false;\r\n\r\n                        // connect to the ws\r\n                        this.privConversation.startConversationAsync(\r\n                            ((): void => {\r\n                                this.handleCallback(param2, param3);\r\n                            }),\r\n                            ((error: any): void => {\r\n                                this.handleError(error, param3);\r\n                            }));\r\n\r\n                    }),\r\n                    ((error: any): void => {\r\n                        this.handleError(error, param3);\r\n                    }));\r\n\r\n            } else if (typeof conversation === \"object\") {\r\n\r\n                Contracts.throwIfNullOrUndefined(conversation, this.privErrors.invalidArgs.replace(\"{arg}\", \"conversation id\"));\r\n                Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace(\"{arg}\", \"nickname\"));\r\n\r\n                // save the nickname\r\n                this.privProperties.setProperty(PropertyId.ConversationTranslator_Name, nickname);\r\n                // ref the conversation object\r\n                this.privConversation = conversation as ConversationImpl;\r\n                // ref the conversation translator object\r\n                this.privConversation.conversationTranslator = this;\r\n                this.privConversation.room.isHost = true;\r\n\r\n                Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedConnect);\r\n                Contracts.throwIfNullOrUndefined(this.privConversation.room.token, this.privErrors.permissionDeniedConnect);\r\n\r\n                this.privSpeechTranslationConfig = conversation.config;\r\n\r\n                this.handleCallback(param1 as Callback, param2);\r\n            } else {\r\n                this.handleError(\r\n                    new Error(this.privErrors.invalidArgs.replace(\"{arg}\", \"invalid conversation type\")),\r\n                    param2);\r\n            }\r\n\r\n        } catch (error) {\r\n            this.handleError(error, typeof param1 === \"string\" ? param3 : param2);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Leave the conversation\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public leaveConversationAsync(cb?: Callback, err?: Callback): void {\r\n\r\n        marshalPromiseToCallbacks((async (): Promise<void> => {\r\n\r\n            // stop the speech websocket\r\n            await this.cancelSpeech();\r\n            // stop the websocket\r\n            await this.privConversation.endConversationImplAsync();\r\n            // https delete request\r\n            await this.privConversation.deleteConversationImplAsync();\r\n            this.dispose();\r\n\r\n        })(), cb, err);\r\n    }\r\n\r\n    /**\r\n     * Send a text message\r\n     * @param message\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public sendTextMessageAsync(message: string, cb?: Callback, err?: Callback): void {\r\n\r\n        try {\r\n            Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedSend);\r\n            Contracts.throwIfNullOrWhitespace(message, this.privErrors.invalidArgs.replace(\"{arg}\", message));\r\n\r\n            this.privConversation.sendTextMessageAsync(message, cb, err);\r\n        } catch (error) {\r\n\r\n            this.handleError(error, err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Start speaking\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public startTranscribingAsync(cb?: Callback, err?: Callback): void {\r\n        marshalPromiseToCallbacks((async (): Promise<void> => {\r\n            try {\r\n                Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedSend);\r\n                Contracts.throwIfNullOrUndefined(this.privConversation.room.token, this.privErrors.permissionDeniedConnect);\r\n\r\n                if (this.privCTRecognizer === undefined) {\r\n                    await this.connectTranslatorRecognizer();\r\n                }\r\n                Contracts.throwIfNullOrUndefined(this.privCTRecognizer, this.privErrors.permissionDeniedSend);\r\n\r\n                if (!this.canSpeak) {\r\n                    this.handleError(new Error(this.privErrors.permissionDeniedSend), err);\r\n                }\r\n\r\n                await this.startContinuousRecognition();\r\n\r\n                this.privIsSpeaking = true;\r\n            } catch (error) {\r\n                this.privIsSpeaking = false;\r\n                await this.cancelSpeech();\r\n                throw error;\r\n            }\r\n        })(), cb, err);\r\n    }\r\n\r\n    /**\r\n     * Stop speaking\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public stopTranscribingAsync(cb?: Callback, err?: Callback): void {\r\n        marshalPromiseToCallbacks((async (): Promise<void> => {\r\n            try {\r\n                if (!this.privIsSpeaking) {\r\n                    // stop speech\r\n                    await this.cancelSpeech();\r\n                    return;\r\n                }\r\n\r\n                // stop the recognition but leave the websocket open\r\n                this.privIsSpeaking = false;\r\n                await new Promise((resolve: () => void, reject: (error: string) => void): void => {\r\n                    this.privCTRecognizer.stopContinuousRecognitionAsync(resolve, reject);\r\n                });\r\n\r\n            } catch (error) {\r\n                await this.cancelSpeech();\r\n            }\r\n        })(), cb, err);\r\n    }\r\n\r\n    public isDisposed(): boolean {\r\n        return this.privIsDisposed;\r\n    }\r\n\r\n    public dispose(reason?: string, success?: () => void, err?: (error: string) => void): void {\r\n        marshalPromiseToCallbacks((async (): Promise<void> => {\r\n            if (this.isDisposed && !this.privIsSpeaking) {\r\n                return;\r\n            }\r\n            await this.cancelSpeech();\r\n            this.privIsDisposed = true;\r\n            this.privSpeechTranslationConfig.close();\r\n            this.privSpeechRecognitionLanguage = undefined;\r\n            this.privProperties = undefined;\r\n            this.privAudioConfig = undefined;\r\n            this.privSpeechTranslationConfig = undefined;\r\n            this.privConversation.dispose();\r\n            this.privConversation = undefined;\r\n        })(), success, err);\r\n    }\r\n\r\n    /**\r\n     * Cancel the speech websocket\r\n     */\r\n    private async cancelSpeech(): Promise<void> {\r\n        try {\r\n            this.privIsSpeaking = false;\r\n            await this.privCTRecognizer?.onDisconnection();\r\n            this.privCTRecognizer = undefined;\r\n        } catch (e) {\r\n            // ignore the error\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Connect to the speech translation recognizer.\r\n     * Currently there is no language validation performed before sending the SpeechLanguage code to the service.\r\n     * If it's an invalid language the raw error will be: 'Error during WebSocket handshake: Unexpected response code: 400'\r\n     * e.g. pass in 'fr' instead of 'fr-FR', or a text-only language 'cy'\r\n     */\r\n    private async connectTranslatorRecognizer(): Promise<void> {\r\n        try {\r\n\r\n            if (this.privAudioConfig === undefined) {\r\n                this.privAudioConfig = AudioConfig.fromDefaultMicrophoneInput();\r\n            }\r\n\r\n            // clear the temp subscription key if it's a participant joining\r\n            if (this.privSpeechTranslationConfig.getProperty(PropertyId[PropertyId.SpeechServiceConnection_Key])\r\n                === this.privPlaceholderKey) {\r\n                this.privSpeechTranslationConfig.setProperty(PropertyId[PropertyId.SpeechServiceConnection_Key], \"\");\r\n            }\r\n\r\n            const convGetter = (): ConversationImpl => this.privConversation;\r\n            this.privCTRecognizer = new ConversationTranslationRecognizer(this.privSpeechTranslationConfig, this.privAudioConfig, this, convGetter);\r\n        } catch (error) {\r\n            await this.cancelSpeech();\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle the start speaking request\r\n     */\r\n    private startContinuousRecognition(): Promise<void> {\r\n        return new Promise((resolve: () => void, reject: (error: string) => void): void => {\r\n            this.privCTRecognizer.startContinuousRecognitionAsync(resolve, reject);\r\n        });\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}